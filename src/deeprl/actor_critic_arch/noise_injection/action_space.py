from abc import ABC, abstractmethod
from itertools import count

import numpy as np
import torch
from torch import Size, Tensor


class ActionNoise(ABC):
    """Random process for action exploration"""

    @abstractmethod
    def __call__(self, size: Size, device: torch.device) -> Tensor:
        ...


class Gaussian(ActionNoise):
    """https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise"""

    def __init__(self, stddev: float, decay_constant: float = 0) -> None:
        self.stddev = stddev
        self.decay_constant = decay_constant
        self._time = count(start=0, step=1)

    def __call__(self, size: Size, device: torch.device) -> Tensor:
        self.stddev = self.stddev * np.exp(-self.decay_constant * next(self._time))
        return self.stddev * torch.randn(size, device=device)


class OrnsteinUhlenbeck(ActionNoise):
    """
    It stabilises zero-mean Gaussian Noise.
    It helps agent explore better in an inertial system.
    Don't abuse Ornstein-Uhlenbeck Process. It has too much hyperparameters and over fine-tuning make no sense.
    """

    def __init__(self) -> None:
        ...

    def __call__(self, size: Size, device: torch.device) -> Tensor:
        """Output noise generated by Ornstein-Uhlenbeck Process"""
        ...
